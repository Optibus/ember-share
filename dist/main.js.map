{"version":3,"sources":["webpack://ember-share/webpack/universalModuleDefinition","webpack://ember-share/./lib/ember-share.js","webpack://ember-share/./lib/ember-share/attr.js","webpack://ember-share/./lib/ember-share/belongs-to.js","webpack://ember-share/./lib/ember-share/inflector/inflections.js","webpack://ember-share/./lib/ember-share/inflector/inflector.js","webpack://ember-share/./lib/ember-share/mixins/share-text.js","webpack://ember-share/./lib/ember-share/models/base.js","webpack://ember-share/./lib/ember-share/models/model.js","webpack://ember-share/./lib/ember-share/models/sub-array.js","webpack://ember-share/./lib/ember-share/models/sub-mixin.js","webpack://ember-share/./lib/ember-share/models/subs-handler.js","webpack://ember-share/./lib/ember-share/models/use-subs-mixin.js","webpack://ember-share/./lib/ember-share/models/utils.js","webpack://ember-share/./lib/ember-share/store.js","webpack://ember-share/./lib/ember-share/utils.js","webpack://ember-share/webpack/bootstrap","webpack://ember-share/webpack/runtime/define property getters","webpack://ember-share/webpack/runtime/hasOwnProperty shorthand","webpack://ember-share/webpack/runtime/make namespace object","webpack://ember-share/webpack/startup"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;;;ACV6D;AACT;AACZ;AACA;AACE;AACU;;AAEpD,OAAO,YAAY,GAAG,4DAAY;AAClC,OAAO,iBAAiB,GAAG,4DAAY;;AAEvC,aAAa,0DAAQ;;AAErB,iEAAe;AACf,gBAAgB;AAChB,YAAY;AACZ;AACA;AACA,OAAO;AACP,OAAO;AACP;AACA,CAAC,EAAC;;;;;;;;;;;;;;;ACpBF;AACA;AACA;;AAEA,6BAAe,oCAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;;;;;AC5DA,iEAAe;AACf;AACA;;AAEA;AACA;AACA;AACA,gEAAgE,EAAE;AAClE,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,uEAAuE,EAAE;AACzE,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH,CAAC,EAAC;;;;;;;;;;;;;;;AC5BF,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;AChFuC;;AAEzC,OAAO,aAAa;;AAEpB;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS,eAAe,YAAY;AACvD;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS,kBAAkB,YAAY;AAC1D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,4BAA4B;AAC5B,+BAA+B;AAC/B;;AAEA;;AAEA;AACA;;AAEA,+BAA+B;AAC/B;AACA,+BAA+B;;AAE/B,gCAAgC;AAChC;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,GAAG;;AAEH,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,YAAY,GAAG,KAAK;AAChE,GAAG;;AAEH;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,KAAK;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA,yBAAyB,iDAAY;AACrC,oCAAoC,iDAAY;;AAEhD,iEAAe,mBAAmB,EAAC;;;;;;;;;;;;;;;;ACxVnC;AACA;AACA;AACA;AACA;AACyC;;AAEzC,iEAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAAS;AAChC;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC,CAAC,EAAC;;;;;;;;;;;;;;;;;;;;ACzGyC;AACT;AACG;AACJ;AACN;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,+CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC;;AAED,yBAAyB,oDAAY;AACrC,yDAAW,kBAAkB,+CAAQ;AACrC,wDAAU,GAAG,mDAAW,CAAC,+CAAQ,6BAA6B,oDAAY;;AAE1E,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;ACvIK;AACC;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,iDAAc;AAC9B;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,kBAAkB,+CAAK;AACvB;;AAEA;AACA;AACA;;AAEA,QAAQ,KAAQ,EAAE,EAGb;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,+CAAK;AAC3B;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH,CAAC;;AAED,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;ACvEY;AACP;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAAe,oCAAU;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAK;;AAEzB;AACA;AACA,kBAAkB,cAAc,GAAG,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D,eAAe;AACf;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO,GAAG,MAAM;AAClD;AACA;AACA;AACA;AACA,+BAA+B,OAAO,GAAG,MAAM;AAC/C;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB;AACnE;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,8CAA8C;AAC9C,+CAA+C,oBAAoB;AACnE,KAAK;AACL,GAAG;AACH;;;;;;;;;;;;;;;;;AC5K4B;AACA;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;AACf;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,iBAAiB,8CAAK;AACtB;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA,kBAAkB,+CAAK;;AAEvB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO,GAAG,IAAI,GAAG,KAAK;AACxC;AACA,gBAAgB,OAAO,GAAG,KAAK;AAC/B;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,2CAA2C,OAAO,GAAG,IAAI;;AAEzD;AACA;AACA;;AAEA;AACA,kBAAkB,+CAAK;;AAEvB;;AAEA;AACA,iCAAiC,uBAAuB;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB,GAAG,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,sCAAsC,EAAE,GAAG,IAAI;AAC/C,gCAAgC,KAAK;AACrC,GAAG;;AAEH;AACA,iBAAiB,8CAAK;AACtB;AACA;AACA;AACA,GAAG;;AAEH;AACA,kBAAkB,+CAAK;AACvB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC,CAAC,EAAC;;;;;;;;;;;;;;;ACzKH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;AACf,YAAY;AACZ,WAAW;AACX,CAAC,EAAC;;;;;;;;;;;;;;;;;ACXgC;AACN;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;AACf;AACA,kBAAkB,+CAAK;;AAEvB;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,EAAE,GAAG,IAAI;AACjD;AACA,mEAAmE,KAAK;AACxE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,gBAAgB,kDAAI;AACpB;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,CAAC,CAAC,EAAC;;;;;;;;;;;;;;;AC5DY;AACf;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,yBAAyB,IAAI;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,yBAAyB,IAAI;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO,GAAG,KAAK;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA,aAAa;AACb,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,qDAAqD,uBAAuB;AAC5E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;ACrSA;AAC2C;AACG;;AAE9C,KAAK,yBAAyB,GAAG,yDAAS;AAC1C,+BAA+B,yDAAS;AACxC,2BAA2B,yDAAS;AACpC,OAAO,UAAU;AACjB;;AAEA;;AAEA,iEAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,mDAAmD,kBAAkB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM,kDAAU;AAChB;AACA;AACA;AACA,sBAAsB,qBAAqB,KAAK,SAAS;AACzD,4CAA4C,iBAAiB;AAC7D;AACA,wBAAwB,GAAG;AAC3B;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,oCAAoC,UAAU;AAC9C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4CAAI;AAC9B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,8BAA8B,UAAU;AACxC;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;AACA,UAAU;AACV,kCAAkC,QAAQ;AAC1C;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA,QAAQ;AACR,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,2DAA2D,kBAAkB;AAC7E;AACA,GAAG;AACH;AACA,2DAA2D,kBAAkB;AAC7E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8CAA8C,SAAS,GAAG,kBAAkB;AAC5E,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,6CAA6C,KAAK;AAClD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH,CAAC,CAAC,EAAC;;;;;;;;;;;;;;;;;;AC1fH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA,eAAe,gCAAgC;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,6BAA6B;;AAEpD;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,wBAAwB;AAC/C;AACA,GAAG;AACH;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;;;;;;;UC9O3C;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,sF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;UCNA;UACA;UACA;UACA","file":"main.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ember-share\"] = factory();\n\telse\n\t\troot[\"ember-share\"] = factory();\n})(self, function() {\nreturn ","import ShareTextMixin from \"./ember-share/mixins/share-text\";\nimport ShareProxy from \"./ember-share/models/model\";\nimport Store from \"./ember-share/store\";\nimport Utils from \"./ember-share/utils\";\nimport attrFunc from \"./ember-share/attr\";\nimport belongsToObj from \"./ember-share/belongs-to\";\n\nconst { belongsTo } = belongsToObj;\nconst { belongsToShare } = belongsToObj;\n\nconst attr = attrFunc(\"_sdbProps\");\n\nexport default {\n  ShareTextMixin,\n  ShareProxy,\n  belongsTo,\n  belongsToShare,\n  Store,\n  Utils,\n  attr,\n};\n","const sillyFunction = function (value) {\n  return value;\n};\n\nexport default function (sdbProps) {\n  return function () {\n    let options;\n    let type;\n    options = {};\n    type = null;\n    _.forEach(arguments, function (arg) {\n      if (_.isPlainObject(arg)) {\n        return (options = arg);\n      }\n      if (_.isString(arg)) {\n        return (type = arg.charAt(0).toUpperCase() + arg.slice(1));\n      }\n    });\n    if (type != null && window[type] != null) {\n      var transfromToType = function (value) {\n        const newValue = new window[type](value);\n        if (type == \"Date\") return newValue;\n        return newValue.valueOf();\n      };\n    } else {\n      var transfromToType = sillyFunction;\n    }\n\n    return Ember.computed({\n      get(k) {\n        this.get(sdbProps, true).addObject(k);\n        const isSpecielKey = _.includes(\n          [\n            \"_isSDB\",\n            \"_sdbProps\",\n            \"_subProps\",\n            \"doc\",\n            \"_prefix\",\n            \"content\",\n            \"_idx\",\n            \"_root\",\n          ],\n          k\n        );\n\n        if (isSpecielKey || this._fullPath == null)\n          return transfromToType(this._get(k, true));\n        return transfromToType(this._get(this._fullPath(k)));\n      },\n      set(k, v, isFromServer) {\n        const path =\n          k == null\n            ? this.get(\"_prefix\")\n            : k == \"_idx\" || !this._fullPath\n            ? k\n            : this._fullPath(k);\n        return this._set(path, v);\n      },\n    });\n  };\n}\n","export default {\n  belongsToShare(DS, modelName) {\n    const store = this.ShareStore;\n\n    return Ember.computed({\n      get(k) {\n        let ref;\n        return store.findRecord(modelName, this.get(`doc.data.${k}`));\n      },\n      set(p, oi, isFromServer) {\n        return oi;\n      },\n    });\n  },\n\n  belongsTo(DS, modelName) {\n    const store = this.originalStore;\n    return Ember.computed({\n      get(k) {\n        let ref;\n\n        return store.findRecord(modelName, this.get((ref = `doc.data.${k}`)));\n      },\n      set(p, oi, isFromServer) {\n        return oi;\n      },\n    });\n  },\n};\n","export default {\n  plurals: [\n    [/$/, \"s\"],\n    [/s$/i, \"s\"],\n    [/^(ax|test)is$/i, \"$1es\"],\n    [/(octop|vir)us$/i, \"$1i\"],\n    [/(octop|vir)i$/i, \"$1i\"],\n    [/(alias|status|bonus)$/i, \"$1es\"],\n    [/(bu)s$/i, \"$1ses\"],\n    [/(buffal|tomat)o$/i, \"$1oes\"],\n    [/([ti])um$/i, \"$1a\"],\n    [/([ti])a$/i, \"$1a\"],\n    [/sis$/i, \"ses\"],\n    [/(?:([^f])fe|([lr])f)$/i, \"$1$2ves\"],\n    [/(hive)$/i, \"$1s\"],\n    [/([^aeiouy]|qu)y$/i, \"$1ies\"],\n    [/(x|ch|ss|sh)$/i, \"$1es\"],\n    [/(matr|vert|ind)(?:ix|ex)$/i, \"$1ices\"],\n    [/^(m|l)ouse$/i, \"$1ice\"],\n    [/^(m|l)ice$/i, \"$1ice\"],\n    [/^(ox)$/i, \"$1en\"],\n    [/^(oxen)$/i, \"$1\"],\n    [/(quiz)$/i, \"$1zes\"],\n  ],\n\n  singular: [\n    [/s$/i, \"\"],\n    [/(ss)$/i, \"$1\"],\n    [/(n)ews$/i, \"$1ews\"],\n    [/([ti])a$/i, \"$1um\"],\n    [\n      /((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(sis|ses)$/i,\n      \"$1sis\",\n    ],\n    [/(^analy)(sis|ses)$/i, \"$1sis\"],\n    [/([^f])ves$/i, \"$1fe\"],\n    [/(hive)s$/i, \"$1\"],\n    [/(tive)s$/i, \"$1\"],\n    [/([lr])ves$/i, \"$1f\"],\n    [/([^aeiouy]|qu)ies$/i, \"$1y\"],\n    [/(s)eries$/i, \"$1eries\"],\n    [/(m)ovies$/i, \"$1ovie\"],\n    [/(x|ch|ss|sh)es$/i, \"$1\"],\n    [/^(m|l)ice$/i, \"$1ouse\"],\n    [/(bus)(es)?$/i, \"$1\"],\n    [/(o)es$/i, \"$1\"],\n    [/(shoe)s$/i, \"$1\"],\n    [/(cris|test)(is|es)$/i, \"$1is\"],\n    [/^(a)x[ie]s$/i, \"$1xis\"],\n    [/(octop|vir)(us|i)$/i, \"$1us\"],\n    [/(alias|status|bonus)(es)?$/i, \"$1\"],\n    [/^(ox)en/i, \"$1\"],\n    [/(vert|ind)ices$/i, \"$1ex\"],\n    [/(matr)ices$/i, \"$1ix\"],\n    [/(quiz)zes$/i, \"$1\"],\n    [/(database)s$/i, \"$1\"],\n  ],\n\n  irregularPairs: [\n    [\"person\", \"people\"],\n    [\"man\", \"men\"],\n    [\"child\", \"children\"],\n    [\"sex\", \"sexes\"],\n    [\"move\", \"moves\"],\n    [\"cow\", \"kine\"],\n    [\"zombie\", \"zombies\"],\n  ],\n\n  uncountable: [\n    \"equipment\",\n    \"information\",\n    \"rice\",\n    \"money\",\n    \"species\",\n    \"series\",\n    \"fish\",\n    \"sheep\",\n    \"jeans\",\n    \"police\",\n  ],\n};\n","import defaultRules from \"./inflections\";\n\nconst { capitalize } = _;\n\nconst BLANK_REGEX = /^\\s*$/;\nconst LAST_WORD_DASHED_REGEX = /([\\w/-]+[_/\\s-])([a-z\\d]+$)/;\nconst LAST_WORD_CAMELIZED_REGEX = /([\\w/\\s-]+)([A-Z][a-z\\d]*$)/;\nconst CAMELIZED_REGEX = /[A-Z][a-z\\d]*$/;\n\nfunction loadUncountable(rules, uncountable) {\n  for (let i = 0, { length } = uncountable; i < length; i++) {\n    rules.uncountable[uncountable[i].toLowerCase()] = true;\n  }\n}\n\nfunction loadIrregular(rules, irregularPairs) {\n  let pair;\n\n  for (let i = 0, { length } = irregularPairs; i < length; i++) {\n    pair = irregularPairs[i];\n\n    // pluralizing\n    rules.irregular[pair[0].toLowerCase()] = pair[1];\n    rules.irregular[pair[1].toLowerCase()] = pair[1];\n\n    // singularizing\n    rules.irregularInverse[pair[1].toLowerCase()] = pair[0];\n    rules.irregularInverse[pair[0].toLowerCase()] = pair[0];\n  }\n}\n\n/**\n Inflector.Ember provides a mechanism for supplying inflection rules for your\n application. Ember includes a default set of inflection rules, and provides an\n API for providing additional rules.\n\n Examples:\n\n Creating an inflector with no rules.\n\n ```js\n var inflector = new Ember.Inflector();\n ```\n\n Creating an inflector with the default ember ruleset.\n\n ```js\n var inflector = new Ember.Inflector(Ember.Inflector.defaultRules);\n\n inflector.pluralize('cow'); //=> 'kine'\n inflector.singularize('kine'); //=> 'cow'\n ```\n\n Creating an inflector and adding rules later.\n\n ```javascript\n var inflector = Ember.Inflector.inflector;\n\n inflector.pluralize('advice'); // => 'advices'\n inflector.uncountable('advice');\n inflector.pluralize('advice'); // => 'advice'\n\n inflector.pluralize('formula'); // => 'formulas'\n inflector.irregular('formula', 'formulae');\n inflector.pluralize('formula'); // => 'formulae'\n\n // you would not need to add these as they are the default rules\n inflector.plural(/$/, 's');\n inflector.singular(/s$/i, '');\n ```\n\n Creating an inflector with a nondefault ruleset.\n\n ```javascript\n var rules = {\n    plurals:  [\n      [ /$/, 's' ]\n    ],\n    singular: [\n      [ /\\s$/, '' ]\n    ],\n    irregularPairs: [\n      [ 'cow', 'kine' ]\n    ],\n    uncountable: [ 'fish' ]\n  };\n\n var inflector = new Ember.Inflector(rules);\n ```\n\n @class Inflector\n @namespace Ember\n */\nfunction Inflector(ruleSet) {\n  ruleSet = ruleSet || {};\n  ruleSet.uncountable = ruleSet.uncountable || makeDictionary();\n  ruleSet.irregularPairs = ruleSet.irregularPairs || makeDictionary();\n\n  const rules = (this.rules = {\n    plurals: ruleSet.plurals || [],\n    singular: ruleSet.singular || [],\n    irregular: makeDictionary(),\n    irregularInverse: makeDictionary(),\n    uncountable: makeDictionary(),\n  });\n\n  loadUncountable(rules, ruleSet.uncountable);\n  loadIrregular(rules, ruleSet.irregularPairs);\n\n  this.enableCache();\n}\n\nif (!Object.create && !Object.create(null).hasOwnProperty) {\n  throw new Error(\n    \"This browser does not support Object.create(null), please polyfil with es5-sham: http://git.io/yBU2rg\"\n  );\n}\n\nfunction makeDictionary() {\n  const cache = Object.create(null);\n  cache._dict = null;\n  delete cache._dict;\n  return cache;\n}\n\nInflector.prototype = {\n  /**\n     @public\n\n     As inflections can be costly, and commonly the same subset of words are repeatedly\n     inflected an optional cache is provided.\n\n     @method enableCache\n     */\n  enableCache() {\n    this.purgeCache();\n\n    this.singularize = function (word) {\n      this._cacheUsed = true;\n      return (\n        this._sCache[word] || (this._sCache[word] = this._singularize(word))\n      );\n    };\n\n    this.pluralize = function (numberOrWord, word, options = {}) {\n      this._cacheUsed = true;\n      const cacheKey = [numberOrWord, word, options.withoutCount];\n      return (\n        this._pCache[cacheKey] ||\n        (this._pCache[cacheKey] = this._pluralize(numberOrWord, word, options))\n      );\n    };\n  },\n\n  /**\n     @public\n\n     @method purgeCache\n     */\n  purgeCache() {\n    this._cacheUsed = false;\n    this._sCache = makeDictionary();\n    this._pCache = makeDictionary();\n  },\n\n  /**\n     @public\n     disable caching\n\n     @method disableCache;\n     */\n  disableCache() {\n    this._sCache = null;\n    this._pCache = null;\n    this.singularize = function (word) {\n      return this._singularize(word);\n    };\n\n    this.pluralize = function () {\n      return this._pluralize(...arguments);\n    };\n  },\n\n  /**\n     @method plural\n     @param {RegExp} regex\n     @param {String} string\n     */\n  plural(regex, string) {\n    if (this._cacheUsed) {\n      this.purgeCache();\n    }\n    this.rules.plurals.push([regex, string.toLowerCase()]);\n  },\n\n  /**\n     @method singular\n     @param {RegExp} regex\n     @param {String} string\n     */\n  singular(regex, string) {\n    if (this._cacheUsed) {\n      this.purgeCache();\n    }\n    this.rules.singular.push([regex, string.toLowerCase()]);\n  },\n\n  /**\n     @method uncountable\n     @param {String} regex\n     */\n  uncountable(string) {\n    if (this._cacheUsed) {\n      this.purgeCache();\n    }\n    loadUncountable(this.rules, [string.toLowerCase()]);\n  },\n\n  /**\n     @method irregular\n     @param {String} singular\n     @param {String} plural\n     */\n  irregular(singular, plural) {\n    if (this._cacheUsed) {\n      this.purgeCache();\n    }\n    loadIrregular(this.rules, [[singular, plural]]);\n  },\n\n  /**\n     @method pluralize\n     @param {String} word\n     */\n  pluralize() {\n    return this._pluralize(...arguments);\n  },\n\n  _pluralize(wordOrCount, word, options = {}) {\n    if (word === undefined) {\n      return this.inflect(\n        wordOrCount,\n        this.rules.plurals,\n        this.rules.irregular\n      );\n    }\n\n    if (parseFloat(wordOrCount) !== 1) {\n      word = this.inflect(word, this.rules.plurals, this.rules.irregular);\n    }\n\n    return options.withoutCount ? word : `${wordOrCount} ${word}`;\n  },\n\n  /**\n     @method singularize\n     @param {String} word\n     */\n  singularize(word) {\n    return this._singularize(word);\n  },\n\n  _singularize(word) {\n    return this.inflect(word, this.rules.singular, this.rules.irregularInverse);\n  },\n\n  /**\n     @protected\n\n     @method inflect\n     @param {String} word\n     @param {Object} typeRules\n     @param {Object} irregular\n     */\n  inflect(word, typeRules, irregular) {\n    let inflection;\n    let substitution;\n    let result;\n    let lowercase;\n    let wordSplit;\n    let lastWord;\n    let isBlank;\n    let isCamelized;\n    let rule;\n    let isUncountable;\n\n    isBlank = !word || BLANK_REGEX.test(word);\n    isCamelized = CAMELIZED_REGEX.test(word);\n\n    if (isBlank) {\n      return word;\n    }\n\n    lowercase = word.toLowerCase();\n    wordSplit =\n      LAST_WORD_DASHED_REGEX.exec(word) || LAST_WORD_CAMELIZED_REGEX.exec(word);\n\n    if (wordSplit) {\n      lastWord = wordSplit[2].toLowerCase();\n    }\n\n    isUncountable =\n      this.rules.uncountable[lowercase] || this.rules.uncountable[lastWord];\n\n    if (isUncountable) {\n      return word;\n    }\n\n    for (rule in irregular) {\n      if (lowercase.match(`${rule}$`)) {\n        substitution = irregular[rule];\n\n        if (isCamelized && irregular[lastWord]) {\n          substitution = capitalize(substitution);\n          rule = capitalize(rule);\n        }\n\n        return word.replace(new RegExp(rule, \"i\"), substitution);\n      }\n    }\n\n    for (let i = typeRules.length, min = 0; i > min; i--) {\n      inflection = typeRules[i - 1];\n      rule = inflection[0];\n\n      if (rule.test(word)) {\n        break;\n      }\n    }\n\n    inflection = inflection || [];\n\n    rule = inflection[0];\n    substitution = inflection[1];\n\n    result = word.replace(rule, substitution);\n\n    return result;\n  },\n};\n\nInflector.defaultRules = defaultRules;\nInflector.inflector = new Inflector(defaultRules);\n\nexport default Inflector.inflector;\n","/*\n * Share-text mixin, this mixin sends text operations instead of the default\n * behaviour which is to replace the entire string. to utilize the mixin add\n * the text property names to the textKeys array\n */\nimport { isArray, diff } from \"../utils\";\n\nexport default Ember.Mixin.create({\n  textKeys: [],\n  triggerEvents: false,\n  textEvents: function () {\n    const that = this;\n    this._textContexts = new Array(this.textKeys.length);\n\n    // to hold the listners and remove them on destory\n    this._handlers = new Array(this._textContexts.length * 2);\n    for (let i = 0; i < this.textKeys.length; i++) {\n      const key = this.textKeys[i];\n      const subCtx = this._context.createContextAt([key]);\n      this._handlers[key] = new Array(2);\n\n      // server changes -> local\n      this._handlers[key].push(\n        subCtx.on(\"insert\", Ember.run.bind(this, this.handleInsert, key))\n      );\n      this._handlers[key].push(\n        subCtx.on(\"delete\", Ember.run.bind(this, this.handleDelete, key))\n      );\n      this._textContexts[key] = subCtx;\n    }\n  }.on(\"init\"),\n  setUnknownProperty(key, value) {\n    if (this.textKeys.indexOf(key) >= 0) {\n      // local changes -> server\n      this.textOp(key, value);\n    } else {\n      this._super(key, value);\n    }\n  },\n  textOp(key, value) {\n    // when the object was removed but has a lingering binding\n    // propably an assertion is better\n    if (this._context.get() === undefined) {\n      return;\n    }\n    this.propertyWillChange(key);\n    const components = diff.diff(\n      this._cache[key] || \"\",\n      value.replace(/\\r\\n/g, \"\\n\")\n    );\n    this._cache[key] = value.replace(/\\r\\n/g, \"\\n\");\n    let changePosition = 0;\n    for (let i = 0; i < components.length; i++) {\n      if (components[i].added) {\n        this._context.insert([key, changePosition], components[i].value);\n      } else if (components[i].removed) {\n        this._context.remove([key, changePosition], components[i].value.length);\n      }\n      changePosition += components[i].value.length;\n    }\n    this.propertyDidChange(key);\n  },\n  handleInsert(key, position, data) {\n    this.propertyWillChange(key);\n    if (this._cache[key] === undefined) {\n      // force caching\n      this.get(key);\n    }\n    const updatedText =\n      this._cache[key].slice(0, position) +\n      data +\n      this._cache[key].slice(position);\n    this._cache[key] = updatedText;\n    // use trigger to update the view when in DOM\n    if (this.triggerEvents) {\n      this.trigger(\"textInsert\", position, data);\n    }\n    this.propertyDidChange(key);\n  },\n  handleDelete(key, position, data) {\n    if (this._cache[key] === undefined) {\n      // force caching\n      this.get(key);\n    }\n    this.propertyWillChange(key);\n    const { length } = data;\n    const updatedText =\n      this._cache[key].slice(0, position) +\n      this._cache[key].slice(position + length);\n    this._cache[key] = updatedText;\n    // use trigger to update the view when in DOM\n    if (this.triggerEvents) {\n      this.trigger(\"textDelete\", position, data);\n    }\n    this.propertyDidChange(key);\n  },\n  willDestroy() {\n    // remove the listners\n    for (const key in this._textContexts) {\n      this._textContexts[key].removeListener(this._handlers[key][0]);\n      this._textContexts[key].removeListener(this._handlers[key][1]);\n      this._textContexts[key].destroy();\n    }\n    this._super();\n  },\n});\n","import UseSubsMixin from \"./use-subs-mixin\";\nimport SubMixin from \"./sub-mixin\";\nimport SDBSubArray from \"./sub-array\";\nimport subs from \"./subs-handler\";\nimport Utils from \"./utils\";\n\nconst toJson = function (obj) {\n  return obj == null ? void 0 : JSON.parse(JSON.stringify(obj));\n};\n\nconst getPlainObject = function (value) {\n  if (\n    value != null &&\n    !(\n      typeof value === \"string\" ||\n      typeof value === \"number\" ||\n      typeof value === \"boolean\"\n    )\n  )\n    if (typeof value.toJson === \"function\") return value.toJson();\n    else return toJson(value);\n\n  return value;\n};\n\n//\n//   ShareDb Base Class\n//\n//        Root and all subs (currently not arrays) inherit from base.\n//\n//\n\nconst GetterSettersMixin = Ember.Mixin.create({\n  _get(k, selfCall) {\n    const firstValue = _.head(k.split(\".\"));\n\n    if (k != \"_sdbProps\" && _.includes(this.get(\"_sdbProps\"), firstValue)) {\n      const content = this.get(`doc.data.${k}`);\n      return this.useSubs(content, k);\n    }\n    return this.get(k);\n  },\n\n  _set(path, oi) {\n    const firstValue = _.first(path.split(\".\"));\n    const self = this;\n\n    if (Ember.get(this, \"_prefix\") == null) this.get(firstValue);\n\n    if (path != \"_sdbProps\" && _.includes(this.get(\"_sdbProps\"), firstValue)) {\n      const od = getPlainObject(this._get(path));\n      oi = getPlainObject(oi);\n      const p = path.split(\".\");\n      const utils = Utils(this);\n      utils.removeChildren(path, true);\n      const op = {\n        p,\n        od,\n        oi,\n      };\n\n      if (od == null) delete op.od;\n\n      if (op.oi != op.od) {\n        this.get(\"doc\").submitOp([op], function (err) {\n          self.get(\"_root\", true).trigger(\"submitted\", err);\n        });\n      }\n\n      return this.useSubs(oi, path);\n    }\n    return this.set(path, oi, true);\n  },\n});\nlet SDBBase = Ember.Object.extend(Ember.Evented, GetterSettersMixin, {\n  _isSDB: true,\n\n  notifyProperties: function notifyProperties(props) {\n    const self = this;\n    _.forEach(props, function (prop) {\n      self.notifyPropertyChange(prop);\n    });\n    return this;\n  },\n\n  notifyDidProperties: function notifyDidProperties(props) {\n    const self = this;\n    _.forEach(props, function (prop) {\n      self.propertyDidChange(prop);\n    });\n    return this;\n  },\n\n  notifyWillProperties: function notifyWillProperties(props) {\n    const self = this;\n    _.forEach(props, function (prop) {\n      self.propertyWillChange(prop);\n    });\n    return this;\n  },\n\n  deleteProperty: function deleteProperty(k) {\n    const doc = this.get(\"doc\");\n    const p = k.split(\".\");\n    const od = getPlainObject(this.get(`_root.${k}`));\n    doc.submitOp([\n      {\n        p,\n        od,\n      },\n    ]);\n  },\n\n  setProperties: function setProperties(obj) {\n    const sdbProps = this.get(\"_sdbProps\");\n    const self = this;\n    const SDBpropsFromObj = _.filter(_.keys(obj), function (key) {\n      self.get(key);\n      return _.includes(sdbProps, key);\n    });\n    const nonSDB = _.reject(_.keys(obj), function (key) {\n      return _.includes(sdbProps, key);\n    });\n    this._super(_.pick(obj, nonSDB));\n    _.forEach(SDBpropsFromObj, function (key) {\n      self.set(key, obj[key]);\n    });\n    return this;\n  },\n});\n\nSDBBase = SDBBase.extend(UseSubsMixin);\nsubs.object = SDBBase.extend(SubMixin);\nsubs.array = SDBSubArray(SubMixin, GetterSettersMixin).extend(UseSubsMixin);\n\nexport default SDBBase;\n","import Utils from \"./utils\";\nimport SDBBase from \"./base\";\n\n//\n//   ShareDb Ember Model Class\n//\n//        extends Base.\n//        this is model has a recursive structure, getting an inner object or array will return\n//        a sub object which is conencted to its parent.\n//        an over view of the entire structure can be found here:\n//        https://www.gliffy.com/go/share/sn1ehtp86ywtwlvhsxid\n//\n//\n\nconst SDBRoot = SDBBase.extend({\n  unload() {\n    return this.get(\"_store\").unload(this.get(\"_type\"), this);\n  },\n\n  id: Ember.computed.reads(\"doc.id\"),\n\n  _childLimiations: function () {\n    return [];\n  }.property(),\n\n  _root: function () {\n    return this;\n  }.property(),\n\n  _children: function () {\n    return {};\n  }.property(),\n\n  _sdbProps: function () {\n    return [];\n  }.property(),\n\n  setOpsInit: function () {\n    const doc = this.get(\"doc\", true);\n    const oldDoc = this.get(\"oldDoc\");\n    const utils = Utils(this);\n    const self = this;\n\n    if (oldDoc) {\n      oldDoc.destroy();\n    }\n\n    if (TEST_ENV) {\n      doc.on(\"before op\", utils.beforeAfter(\"Will\"));\n      doc.on(\"op\", utils.beforeAfter(\"Did\"));\n    } else {\n      doc.on(\"before component\", utils.beforeAfter(\"Will\"));\n      doc.on(\"after component\", utils.beforeAfter(\"Did\"));\n    }\n\n    this.set(\"oldDoc\", doc);\n  }\n    .observes(\"doc\")\n    .on(\"init\"),\n\n  willDestroy() {\n    if (this.get(\"doc\")) {\n      this.get(\"doc\").destroy(() => {\n        const utils = Utils(this);\n        this._super.apply(this, arguments);\n        utils.removeChildren();\n      });\n    }\n  },\n});\n\nexport default SDBRoot;\n","import SubMixin from \"./sub-mixin\";\nimport Utils from \"./utils\";\n\nconst allButLast = function (arr) {\n  return arr.slice(0, arr.length - 1);\n};\n\n//\n//   Sub Array Class\n//\n//        this is An Ember Array Proxy, uses sub mixin and 'Use Sub Mixin'\n//\n//\n\nexport default function (SubMixin, GetterSettersMixin) {\n  return Ember.ArrayProxy.extend(Ember.Evented, SubMixin, GetterSettersMixin, {\n    _isArrayProxy: true,\n\n    arrayContentDidChange(startIdx, removeAmt, addAmt) {\n      const _removeAmt = removeAmt == null ? 0 : removeAmt * -1;\n      if (_removeAmt + (addAmt == null) ? 0 : addAmt)\n        Ember.get(this, \"content\").propertyDidChange(\"lastObject\");\n      return this._super.apply(this, arguments);\n    },\n\n    arrayContentWillChange(startIdx, removeAmt, addAmt) {\n      const children = Ember.get(this, \"_children\");\n      const childrenKeys = Object.keys(children);\n      const prefix = Ember.get(this, \"_prefix\");\n      const self = this;\n      const utils = Utils(this);\n\n      const replaceLastIdx = function (str, idx) {\n        const arr = allButLast(str.split(\".\"));\n        return `${arr.join(\".\")}.${idx}`;\n      };\n      const _removeAmt = removeAmt == null ? 0 : removeAmt * -1;\n      addAmt = addAmt == null ? 0 : addAmt;\n      if (_removeAmt + addAmt)\n        Ember.get(this, \"content\").propertyWillChange(\"lastObject\");\n      const childrenKeysReduced = _.reduce(\n        childrenKeys,\n        function (result, key) {\n          if (allButLast(key.split(\".\")).join(\".\") == prefix) result.push(key);\n          return result;\n        },\n        []\n      );\n      _.forEach(childrenKeysReduced, function (childKey) {\n        const idx = +_.last(childKey.split(\".\"));\n        if (!isNaN(idx)) {\n          const child = children[childKey];\n          if (_removeAmt + addAmt == 0) {\n            if (idx >= addAmt) {\n              utils.removeChildren(childKey, true);\n              Ember.get(self, \"content\").propertyWillChange(\"lastObject\");\n            }\n          } else if (\n            (addAmt && startIdx <= idx) ||\n            (removeAmt && startIdx < idx)\n          ) {\n            const newIdx = idx + _removeAmt + addAmt;\n            const newChildKey = replaceLastIdx(childKey, newIdx);\n            childrenKeys\n              .filter(function (childKeyA) {\n                return childKeyA.match(new RegExp(`^${childKey}\\\\.`));\n              })\n              .forEach(function (grandChildKey) {\n                const grandChild = children[grandChildKey];\n                const newGrandChildKey = grandChildKey.replace(\n                  new RegExp(`^${childKey}`),\n                  newChildKey\n                );\n                grandChild.set(\"_prefix\", newGrandChildKey);\n                delete children[grandChildKey];\n                children[newGrandChildKey] = grandChild;\n              });\n            delete children[childKey];\n            const tempChild = {};\n            tempChild[replaceLastIdx(childKey, newIdx)] = child;\n            _.assign(children, tempChild);\n            Ember.set(child, \"_idx\", newIdx);\n          }\n        }\n      });\n      return this._super.apply(this, arguments);\n    },\n\n    // useSubs:\n\n    replaceContent(content, noSet) {\n      let removeAmt;\n      let addAmt;\n      const prefix = Ember.get(this, \"_prefix\");\n      const children = Ember.get(this, \"_children\");\n      _.forEach(this.toArray(), function (value, index) {\n        const child = children[`${prefix}.${index}`];\n        if (child != null)\n          if (content[index] != null)\n            child.replaceContent(content[index], true);\n          else {\n            delete children[`${prefix}.${index}`];\n            child.destroy();\n          }\n      });\n\n      if (!noSet) this._set(prefix, content);\n\n      Ember.set(this, \"content\", content);\n      return this;\n    },\n\n    _submitOp(p, li, ld) {\n      const path = this.get(\"_prefix\").split(\".\");\n      const op = {\n        p: path.concat(p),\n      };\n\n      if (typeof li !== \"undefined\") op.li = li;\n\n      if (typeof ld !== \"undefined\") op.ld = ld;\n\n      if (li != null || ld != null) {\n        return this.get(\"doc\").submitOp([op]);\n      }\n    },\n\n    objectAt(idx) {\n      const content = this._super(idx);\n      const prefix = this.get(\"_prefix\");\n      return this.useSubs(content, prefix, idx);\n    },\n\n    toJson() {\n      const self = this;\n      return _.map(this.toArray(), function (value) {\n        if (typeof value === \"string\" || typeof value === \"number\")\n          return value;\n        return value.toJson();\n      });\n    },\n\n    _replace(start, len, objects) {\n      if (!_.isArray(objects)) {\n        objects = [objects];\n      }\n      this.arrayContentWillChange(start, len, objects.length);\n      const iterationLength = len > objects.length ? len : objects.length;\n      for (let i = 0; i < iterationLength; i++) {\n        const newIndex = i + start;\n        let obj = objects.objectAt(i);\n        if (obj != null) obj = obj.toJson == null ? obj : obj.toJson();\n        let oldObj = this.objectAt(newIndex);\n        if (oldObj != null)\n          oldObj = oldObj.toJson == null ? oldObj : oldObj.toJson();\n        this._submitOp(newIndex, obj, len > i ? oldObj : undefined);\n      }\n      this.arrayContentDidChange(start, len, objects.length);\n      const realContent = this.get(`doc.data.${this.get(\"_prefix\")}`);\n      if (!_.isEqual(this.get(\"content\"), realContent)) {\n        this.onChangeDoc();\n      }\n      return this;\n    },\n\n    onChangeDoc: function () {\n      // debugger\n      // this.set ('content', this.get('doc.data.' + this.get('_prefix')))\n      // Ember.run.next (this, function () P{})\n      this.replaceContent(this.get(`doc.data.${this.get(\"_prefix\")}`), true);\n    }.observes(\"doc\"),\n  });\n}\n","import Utils from \"./utils\";\nimport attrs from \"../attr\";\n\n//\n//   Sub Mixin\n//\n//        All subs use this mixin (Object and Array)\n//\n//\n\nexport default Ember.Mixin.create({\n  _children: function () {\n    return {};\n  }.property(),\n\n  _sdbProps: function () {\n    return [];\n  }.property(),\n\n  _subProps: function () {\n    return [];\n  }.property(),\n\n  doc: Ember.computed.reads(\"_root.doc\"),\n\n  createInnerAttrs: function () {\n    const tempContent = Ember.get(this, \"tempContent\");\n    const self = this;\n    const attr = attrs(\"_subProps\");\n    const keys = [];\n\n    _.forEach(tempContent, function (value, key) {\n      keys.push(key);\n      Ember.defineProperty(self, key, attr());\n    });\n\n    Ember.get(this, \"_subProps\").addObjects(keys);\n    delete this.tempContent;\n  }.on(\"init\"),\n\n  beforeFn: function () {\n    return [];\n  }.property(),\n  afterFn: function () {\n    return [];\n  }.property(),\n\n  activateListeners: function () {\n    const utils = Utils(this);\n\n    const beforeFn = utils.beforeAfterChild(\"Will\");\n    const afterFn = utils.beforeAfterChild(\"Did\");\n\n    this.removeListeners();\n\n    this.on(\"before op\", beforeFn);\n    this.on(\"op\", afterFn);\n\n    this.get(\"beforeFn\").push(beforeFn);\n    this.get(\"afterFn\").push(afterFn);\n  }\n    .observes(\"doc\")\n    .on(\"init\"),\n\n  _fullPath(path) {\n    const prefix = Ember.get(this, \"_prefix\");\n    const idx = Ember.get(this, \"_idx\");\n\n    if (prefix) {\n      if (idx != null) {\n        return `${prefix}.${idx}.${path}`;\n      }\n      return `${prefix}.${path}`;\n    }\n    return path;\n  },\n\n  deleteProperty(k) {\n    const returnValue = this._super(this._fullPath(k));\n    this.removeKey(k);\n    return returnValue;\n  },\n\n  replaceContent(content, noSet) {\n    this.notifyWillProperties(this.get(\"_subProps\").toArray());\n    const prefix = this.get(\"_prefix\");\n    const idx = this.get(\"_idx\");\n    const path = idx == null ? prefix : `${prefix}.${idx}`;\n\n    if (!noSet) {\n      this._set(path, content);\n    }\n\n    const self = this;\n    const utils = Utils(this);\n\n    utils.removeChildren(path);\n\n    if (_.isEmpty(Object.keys(this))) {\n      Ember.setProperties(this, { tempContent: content });\n      this.createInnerAttrs();\n\n      const notifyFather = function (prefixArr, keys) {\n        if (_.isEmpty(prefixArr))\n          self.get(\"_root\").notifyPropertyChange(keys.join(\".\"));\n        else {\n          const child = self.get._children[prefixArr.join(\".\")];\n          if (child != null)\n            child.notifyPropertyChange(\n              `${prefixArr.join(\".\")}.${keys.join(\".\")}`\n            );\n          else keys.push(prefixArr.pop());\n          notifyFather(prefixArr, keys);\n        }\n      };\n      const prefixArr = prefix.split(\".\");\n      const key = prefixArr.pop();\n\n      notifyFather(prefixArr, [key]);\n    } else {\n      let toDelete;\n      if (_.isPlainObject(content)) {\n        toDelete = _.difference(Object.keys(this), Object.keys(content));\n      } else {\n        toDelete = Object.keys(this);\n      }\n\n      _.forEach(toDelete, (prop) => {\n        delete self[prop];\n      });\n      this.get(\"_subProps\").removeObjects(toDelete);\n      Ember.setProperties(this, { tempContent: content });\n      this.createInnerAttrs();\n    }\n    this.notifyDidProperties(this.get(\"_subProps\").toArray());\n\n    return this;\n  },\n\n  toJson() {\n    const idx = Ember.get(this, \"_idx\");\n    const k = Ember.get(this, \"_prefix\");\n    const path = idx == null ? k : `${k}.${idx}`;\n    return this.get(`doc.data.${path}`);\n  },\n\n  addKey(key) {\n    const attr = attrs(\"_subProps\");\n    if (!(this.get(\"_subProps\").indexOf(key) > -1))\n      Ember.defineProperty(this, key, attr());\n    return this;\n  },\n\n  removeKey(key) {\n    const utils = Utils(this);\n    utils.removeChildren(key, true);\n    this.get(\"_subProps\").removeObject(key);\n    delete this[key];\n    return this;\n  },\n\n  removeListeners() {\n    if (this.has(\"before op\")) {\n      this.off(\"before op\", this.get(\"beforeFn\").pop());\n    }\n    if (this.has(\"op\")) {\n      this.off(\"op\", this.get(\"afterFn\").pop());\n    }\n  },\n});\n","//\n//   Subs Handler\n//\n//        since we have a recursive model structure there is a need for\n//        creating the subs in a common place and then reuse it in its own class.\n//\n//\n\nexport default {\n  object: {},\n  array: {},\n};\n","import subs from \"./subs-handler\";\nimport Utils from \"./utils\";\n\n//\n//   Use Subs Mixin\n//\n//        Used by Base and array (all).\n//\n//\n\nexport default Ember.Mixin.create({\n  useSubs: function useSubs(content, k, idx) {\n    const utils = Utils(this);\n\n    if (utils.matchChildToLimitations(k)) return content;\n\n    if (_.isPlainObject(content)) {\n      content = {\n        tempContent: content,\n      };\n      var use = \"object\";\n    } else if (_.isArray(content)) {\n      content = {\n        content,\n      };\n      var use = \"array\";\n    }\n    if (use) {\n      let child;\n      let _idx;\n      const path = idx == null ? k : `${k}.${idx}`;\n      let ownPath = Ember.get(this, \"_prefix\");\n      if ((_idx = Ember.get(this, \"_idx\")) != null) ownPath += `.${_idx}`;\n      if (path == ownPath) {\n        return this;\n      }\n\n      const children = Ember.get(this, \"_children\");\n      const childrenKeys = Object.keys(children);\n\n      if (_.includes(childrenKeys, path)) return children[path];\n      child = {};\n\n      let sub = subs[use].extend({\n        _children: Ember.get(this, \"_children\"),\n        _prefix: k,\n        _idx: idx,\n        _sdbProps: Ember.get(this, \"_sdbProps\"),\n        _root: Ember.get(this, \"_root\"),\n      });\n\n      sub = sub.create(content);\n\n      child[path] = sub;\n      _.assign(Ember.get(this, \"_children\"), child);\n\n      return sub;\n    }\n    return content;\n  },\n});\n","export default function f(context) {\n  return {\n    isOpOnArray(op) {\n      return op.ld != null || op.lm != null || op.li != null;\n    },\n\n    matchingPaths(as, bs) {\n      let counter = 0;\n      const higherLength = as.length > bs.length ? as.length : bs.length;\n      while (\n        (as[counter] == \"*\" || as[counter] == bs[counter]) &&\n        counter < higherLength\n      ) {\n        counter += 1;\n      }\n      return counter - as.length / 1000;\n    },\n\n    matchChildToLimitations(key) {\n      const childLimiations = Ember.get(context, \"_root._childLimiations\");\n      let prefix = Ember.get(context, \"_prefix\");\n\n      if (prefix == null || key.match(prefix)) prefix = key;\n      else prefix += `.${key}`;\n\n      prefix = prefix.split(\".\");\n      const self = this;\n      return _.some(childLimiations, (_limit) => {\n        const limit = _limit.split(\"/\");\n        return (\n          prefix.length == limit.length &&\n          Math.ceil(self.matchingPaths(limit, prefix)) == prefix.length\n        );\n      });\n    },\n\n    prefixToChildLimiations(key) {\n      const childLimiations = Ember.get(context, \"_root._childLimiations\");\n      let prefix = Ember.get(context, \"_prefix\");\n\n      if (prefix == null || key.match(prefix)) prefix = key;\n      else prefix += `.${key}`;\n\n      prefix = prefix.split(\".\");\n      const self = this;\n      let limiationsArray;\n\n      const relevantLimitIndex = this.findMaxIndex(\n        (limiationsArray = _.map(childLimiations, (_limit) => {\n          const limit = _limit.split(\"/\");\n          const result = Math.ceil(self.matchingPaths(limit, prefix));\n          return result < limit.length ? 0 : result;\n        }))\n      );\n      if (relevantLimitIndex >= 0 && limiationsArray[relevantLimitIndex] > 0) {\n        const relevantLimit = childLimiations[relevantLimitIndex].split(\"/\");\n        let orignalPrefix;\n        const result = prefix.slice(\n          0,\n          Math.ceil(self.matchingPaths(relevantLimit, prefix))\n        );\n        if ((orignalPrefix = Ember.get(context, \"_prefix\"))) {\n          orignalPrefix = orignalPrefix.split(\".\");\n          return result.slice(orignalPrefix.length).join(\".\");\n        }\n        return result.join(\".\");\n      }\n      return key;\n    },\n\n    removeChildren(path, includeSelf) {\n      const children = Ember.get(context, \"_children\");\n      let childrenKeys = Object.keys(children);\n      const prefix = context.get(\"_prefix\");\n      const utils = this;\n\n      if (prefix != null && path && path.indexOf(prefix) != 0) {\n        path = `${prefix}.${path}`;\n      }\n\n      if (path) {\n        childrenKeys = _.reduce(\n          childrenKeys,\n          (result, key) => {\n            if (key == path) {\n              if (includeSelf) result.push(key);\n            } else if (key.indexOf(path) == 0) result.push(key);\n            return result;\n          },\n          []\n        );\n      }\n\n      _.forEach(childrenKeys, (key) => {\n        children[key].removeListeners();\n        children[key].destroy();\n        delete children[key];\n      });\n    },\n\n    comparePathToPrefix(path, prefix) {\n      return Boolean(\n        Math.ceil(this.matchingPaths(path.split(\".\"), prefix.split(\".\")))\n      );\n    },\n\n    cutLast(path, op) {\n      let tempPath;\n      if (this.isOpOnArray(op) && !isNaN(+_.last(path))) {\n        tempPath = _.clone(path);\n        tempPath.pop();\n      }\n      return tempPath || path;\n    },\n\n    comparePathToChildren(path, op) {\n      const utils = this;\n      const children = Ember.get(context, \"_children\");\n      const childrenKeys = Object.keys(children);\n      const hasChildren = _.some(childrenKeys, (childKey) => {\n        const pathsCounter = utils.matchingPaths(\n          childKey.split(\".\"),\n          utils.cutLast(path, op)\n        );\n        return Math.ceil(pathsCounter) == childKey.split(\".\").length;\n      });\n      return !Ember.isEmpty(childrenKeys) && hasChildren;\n    },\n\n    triggerChildren(didWill, op, isFromClient) {\n      const newP = _.clone(op.p);\n      // var children = Ember.get(context, '_children');\n      const children = context.get(\"_children\");\n      const childrenKeys = Object.keys(children);\n      if (Ember.isEmpty(childrenKeys)) return;\n      let child;\n\n      const utils = this;\n      const counterToChild = _.mapKeys(children, (v, childKey) => {\n        if (utils.isOpOnArray(op) && !isNaN(+_.last(childKey.split(\".\"))))\n          return 0;\n        return utils.matchingPaths(\n          utils.cutLast(childKey.split(\".\"), op),\n          utils.cutLast(op.p, op)\n        );\n      });\n      const toNumber = function f(strings) {\n        return _.map(strings, (s) => +s);\n      };\n      const chosenChild =\n        counterToChild[_.max(toNumber(Object.keys(counterToChild)))];\n      if (didWill == \"Will\")\n        chosenChild.trigger(\"before op\", [op], isFromClient);\n      if (didWill == \"Did\") chosenChild.trigger(\"op\", [op], isFromClient);\n    },\n\n    beforeAfter(didWill) {\n      const utils = this;\n      let ex;\n      return function f(ops, isFromClient) {\n        if (!isFromClient) {\n          _.forEach(ops, (op) => {\n            if (utils.comparePathToChildren(op.p, op)) {\n              utils.triggerChildren(didWill, op, isFromClient);\n            } else if (utils.isOpOnArray(op)) {\n              ex = utils.extractArrayPath(op);\n\n              context\n                .get(ex.p)\n                [`arrayContent${didWill}Change`](\n                  ex.idx,\n                  ex.removeAmt,\n                  ex.addAmt\n                );\n            } else {\n              context[`property${didWill}Change`](\n                utils.prefixToChildLimiations(op.p.join(\".\"))\n              );\n            }\n          });\n        }\n      };\n    },\n\n    beforeAfterChild(didWill) {\n      const utils = this;\n      let ex;\n      let prefix;\n      let _idx;\n      return function (ops, isFromClient) {\n        if ((_idx = Ember.get(context, \"_idx\")) != null || !isFromClient) {\n          _.forEach(ops, (op) => {\n            if (\n              op.p.join(\".\") == (prefix = Ember.get(context, \"_prefix\")) &&\n              didWill == \"Did\"\n            ) {\n              if (op.oi != null) {\n                const content = context.get(`_root.doc.data.${prefix}`);\n                context.replaceContent(content, true);\n              } else if (op.od != null) {\n                const fatherPrefix = prefix.split(\".\");\n                const key = fatherPrefix.pop();\n                var father;\n                if (\n                  !_.isEmpty(fatherPrefix) &&\n                  (father = context.get(`_children.${fatherPrefix.join(\".\")}`))\n                )\n                  father.removeKey(key);\n                else context.get(\"_root\").propertyDidChange(prefix);\n              }\n            } else {\n              const path =\n                _idx == null\n                  ? prefix.split(\".\")\n                  : prefix.split(\".\").concat(String(_idx));\n              const newP = _.difference(op.p, path);\n              if (utils.comparePathToPrefix(op.p.join(\".\"), prefix)) {\n                if (\n                  utils.isOpOnArray(op) &&\n                  Ember.get(context, \"_idx\") == null\n                ) {\n                  var newOp = _.clone(op);\n                  newOp.p = newP;\n                  ex = utils.extractArrayPath(newOp);\n\n                  if (ex.p == \"\")\n                    context[`arrayContent${didWill}Change`](\n                      ex.idx,\n                      ex.removeAmt,\n                      ex.addAmt\n                    );\n                  else\n                    Ember.get(context, ex.p)[`arrayContent${didWill}Change`](\n                      ex.idx,\n                      ex.removeAmt,\n                      ex.addAmt\n                    );\n                } else if (newP.join(\".\") == \"\") {\n                  // delete self from father\n                  if (\n                    _.isEmpty(newOp) &&\n                    op.od &&\n                    op.oi == null &&\n                    _.isEqual(op.od, context.toJson())\n                  ) {\n                    const keyToRemove = path.pop();\n                    if (_.isEmpty(path)) {\n                      utils.removeChildren(keyToRemove, true);\n                    } else {\n                      var father = context.get(\"_children\")[path.join(\".\")];\n                      father.removeKey(keyToRemove);\n                    }\n                  } else {\n                    // context[\"property\" + didWill + \"Change\"]('content');\n                  }\n                } else {\n                  if (op.oi && op.od == null) {\n                    context.addKey(_.head(newP));\n                  }\n\n                  if (op.od && op.oi == null) {\n                    context.notifyPropertyChange(\n                      utils.prefixToChildLimiations(newP.join(\".\"))\n                    );\n                    if (newP.length === 1) {\n                      context.removeKey(_.head(newP));\n                    }\n                  } else {\n                    context[`property${didWill}Change`](\n                      utils.prefixToChildLimiations(newP.join(\".\"))\n                    );\n                  }\n                }\n              }\n            }\n          });\n        }\n      };\n    },\n\n    findMaxIndex(arr) {\n      return arr.indexOf(_.max(arr));\n    },\n\n    extractArrayPath(op) {\n      return {\n        idx: +_.last(op.p),\n        p: _.slice(op.p, 0, op.p.length - 1).join(\".\"),\n        addAmt: typeof op.li !== \"undefined\" ? 1 : 0,\n        removeAmt: typeof op.ld !== \"undefined\" ? 1 : 0,\n      };\n    },\n  };\n}\n","/* global BCSocket:false, sharedb:false */\nimport { guid, patchShare } from \"./utils\";\nimport inflector from \"./inflector/inflector\";\n\nlet { singularize, pluralize } = inflector;\nsingularize = singularize.bind(inflector);\npluralize = pluralize.bind(inflector);\nconst { Promise } = Ember.RSVP;\nconst socketReadyState = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSE\"];\n\nconst ObjectPromiseProxy = Ember.ObjectProxy.extend(Ember.PromiseProxyMixin);\n\nexport default Ember.Object.extend(Ember.Evented, {\n  socket: null,\n  connection: null,\n\n  // port: 3000,\n  // url : 'https://qa-e.optibus.co',\n  url: window.location.hostname,\n  init() {\n    const store = this;\n\n    this.checkSocket = function () {\n      return new Promise(function (resolve, reject) {\n        if (store.socket == null) {\n          store.one(\"connectionOpen\", resolve);\n        } else {\n          const checkState = function (state, cb) {\n            switch (state) {\n              case \"connected\":\n                return resolve();\n              case \"connecting\":\n                return store.connection.once(\"connected\", resolve);\n              default:\n                cb(state);\n            }\n          };\n          const checkStateFail = function (state) {\n            switch (state) {\n              case \"closed\":\n                return reject(\"connection closed\");\n              case \"disconnected\":\n                return reject(\"connection disconnected\");\n              case \"stopped\":\n                return reject(\"connection closing\");\n            }\n          };\n          let failed = false;\n          checkState(store.connection.state, function (state) {\n            if (failed) checkStateFail(state);\n            else\n              Ember.run.next(this, function () {\n                failed = true;\n                checkState(store.connection.state, checkStateFail);\n              });\n          });\n        }\n      });\n    };\n\n    this.checkConnection = function () {\n      return new Promise(function (resolve, reject) {\n        return store\n          .checkSocket()\n          .then(function () {\n            return resolve();\n            if (store.authentication != null && store.isAuthenticated != null) {\n              if (store.isAuthenticated) return resolve();\n              if (store.isAuthenticating)\n                return store.one(\"authenticated\", resolve);\n              if (!store.isAuthenticated)\n                return store.authentication(store.connection.id);\n              // if (!store.isAuthenticating) return reject()\n              return reject(\"could not authenticat\");\n            }\n            return resolve();\n          })\n          .catch(function (err) {\n            return reject(err);\n          });\n      });\n    };\n\n    this.cache = {};\n    if (!window.sharedb) {\n      throw new Error(\"sharedb client not included\");\n    }\n    if (window.BCSocket === undefined && window.Primus === undefined) {\n      throw new Error(\"No Socket library included\");\n    }\n    if (this.beforeConnect) {\n      this.beforeConnect().then(function () {\n        store.trigger(\"connect\");\n      });\n    } else {\n      store.trigger(\"connect\");\n    }\n  },\n  doConnect: function (options) {\n    const store = this;\n\n    if (window.BCSocket) {\n      this.setProperties(options);\n      this.socket = new BCSocket(this.get(\"url\"), { reconnect: true });\n      this.socket.onerror = function (err) {\n        store.trigger(\"connectionError\", [err]);\n      };\n      this.socket.onopen = function () {\n        store.trigger(\"connectionOpen\");\n      };\n      this.socket.onclose = function () {\n        store.trigger(\"connectionEnd\");\n      };\n    } else if (window.Primus) {\n      patchShare();\n      this.setProperties(options);\n      let hostname = this.get(\"url\");\n      if (this.get(\"protocol\"))\n        hostname = `${this.get(\"protocol\")}://${hostname}`;\n      if (this.get(\"port\")) hostname += `:${this.get(\"port\")}`;\n      else {\n        hostname += `:${80}`;\n      }\n      this.socket = new Primus(hostname, options);\n      // console.log('connection starting');\n\n      this.socket.on(\"error\", function error(err) {\n        store.trigger(\"connectionError\", [err]);\n      });\n      this.socket.on(\"open\", function () {\n        // console.log('connection open');\n        store.trigger(\"connectionOpen\");\n      });\n      this.socket.on(\"end\", function () {\n        store.trigger(\"connectionEnd\");\n      });\n      this.socket.on(\"close\", function () {\n        store.trigger(\"connectionEnd\");\n      });\n    } else {\n      throw new Error(\"No Socket library included\");\n    }\n    const oldHandleMessage = sharedb.Connection.prototype.handleMessage;\n    const oldSend = sharedb.Connection.prototype.send;\n\n    store.on(\"connectionEnd\", function () {\n      // console.log('ending connection');\n      store.isAuthenticated = false;\n    });\n\n    sharedb.Connection.prototype.handleMessage = function (message) {\n      let athenticating;\n      let handleMessageArgs;\n      handleMessageArgs = arguments;\n      // console.log(message.a);\n      const context = this;\n      oldHandleMessage.apply(context, handleMessageArgs);\n      if (\n        message.a === \"init\" &&\n        typeof message.id === \"string\" &&\n        message.protocol === 1 &&\n        typeof store.authenticate === \"function\"\n      ) {\n        store.isAuthenticating = true;\n        return store\n          .authenticate(message.id)\n          .then(function () {\n            console.log(\"authenticated !\");\n            store.isAuthenticating = false;\n            store.isAuthenticated = true;\n            oldHandleMessage.apply(context, handleMessageArgs);\n            store.trigger(\"authenticated\");\n          })\n          .catch(function (err) {\n            store.isAuthenticating = false;\n            // store.socket.end()\n          });\n      }\n    };\n\n    this.connection = new sharedb.Connection(this.socket);\n  }.on(\"connect\"),\n  find(type, id) {\n    type = pluralize(type);\n    const store = this;\n    return this.checkConnection().then(function () {\n      return store.findQuery(type, { _id: id }).then(\n        function (models) {\n          return models[0];\n        },\n        function (err) {\n          return err;\n        }\n      );\n    });\n  },\n  createRecord(type, data) {\n    let ref;\n    let path;\n    path = (ref = this._getPathForType(type)) ? ref : type.pluralize();\n    path = this._getPrefix(type) + path;\n    type = pluralize(type);\n    const store = this;\n    return store.checkConnection().then(function () {\n      const doc = store.connection.get(\n        path,\n        data.id == null ? guid() : data.id\n      );\n      return Promise.all([\n        store.whenReady(doc).then(function (doc) {\n          return store.create(doc, data);\n        }),\n        store.subscribe(doc),\n      ]).then(function () {\n        const model = store._createModel(type, doc);\n        store._cacheFor(type).addObject(model);\n        return model;\n      });\n    });\n  },\n  deleteRecord(type, id) {\n    const cache = this._cacheFor(pluralize(type));\n    const model = cache.findBy(\"id\", id);\n    const doc = model.get(\"doc\");\n    return new Promise(function (resolve, reject) {\n      doc.del(function (err) {\n        if (err != null) reject(err);\n        else {\n          resolve();\n        }\n      });\n    });\n  },\n  findAndSubscribeQuery(type, query) {\n    type = pluralize(type);\n    const store = this;\n    const prefix = this._getPrefix(type);\n    // store.cache[type] = []\n\n    return this.checkConnection().then(function () {\n      return new Promise(function (resolve, reject) {\n        let fetchedResult;\n        let _query;\n        function fetchQueryCallback(err, results, extra) {\n          if (err !== null) {\n            return reject(err);\n          }\n          resolve(\n            store._resolveModels(type, results).then(function (models) {\n              fetchedResult = models;\n              return { models, query: _query };\n            })\n          );\n        }\n        _query = store.connection.createSubscribeQuery(\n          prefix + type,\n          query,\n          null,\n          fetchQueryCallback\n        );\n        _query.on(\"insert\", function (docs) {\n          store._resolveModels(type, docs).then(function (models) {\n            return fetchedResult.addObjects(models);\n          });\n        });\n        _query.on(\"remove\", function (docs) {\n          store._resolveModels(type, docs).then(function (models) {\n            _.forEach(models, function (model) {\n              store.unload(type, model);\n            });\n            return fetchedResult.removeObjects(models);\n          });\n        });\n      });\n    });\n  },\n  findRecord(type, id) {\n    const store = this;\n    const cache = store.cache[pluralize(type)];\n    return ObjectPromiseProxy.create({\n      promise: new Promise(function (resolve, reject) {\n        try {\n          var cachedRecordAvailable =\n            cache[0].doc.id == id && cache.length == 1;\n        } catch (e) {}\n        if (cachedRecordAvailable) {\n          resolve(cache[0]);\n        } else {\n          store\n            .findQuery(type, { _id: id })\n            .then(function (results) {\n              resolve(results[0]);\n            })\n            .catch(function (err) {\n              reject(err);\n            });\n        }\n      }),\n    });\n    // return new Promise(function (resolve, reject){\n    //   try {\n    //     var cachedRecordAvailable = cache[0].doc.id == id && cache.length == 1\n    //   } catch (e) { }\n    //   if (cachedRecordAvailable) {\n    //     resolve(cache[0])\n    //   } else {\n    //     store.findQuery(type, {_id: id})\n    //       .then(function(results){\n    //         resolve(results[0])\n    //       })\n    //       .catch(function (err){\n    //         reject(err)\n    //       });\n    //   }\n    // })\n  },\n  findQuery(type, query) {\n    // type = pluralize(type)\n    let ref;\n    let path;\n    path = (ref = this._getPathForType(type)) ? ref : pluralize(type);\n    path = this._getPrefix(type) + path;\n    const store = this;\n    // store.cache[pluralize(type)] = []\n    return this.checkConnection().then(function () {\n      return new Promise(function (resolve, reject) {\n        function fetchQueryCallback(err, results, extra) {\n          if (err !== null) {\n            return reject(err);\n          }\n          resolve(store._resolveModels(type, results));\n        }\n        store.connection.createFetchQuery(\n          path,\n          query,\n          null,\n          fetchQueryCallback\n        );\n      });\n    });\n  },\n  findAll(type, query) {\n    type = pluralize(type);\n    throw new Error(\"findAll not implemented\");\n    // TODO this.connection subscribe style query\n  },\n  _cacheFor(type) {\n    type = pluralize(type);\n    let cache = this.cache[type];\n    if (cache === undefined) {\n      this.cache[type] = cache = [];\n    }\n    return cache;\n  },\n  _getPathForType(type) {\n    const Adapter = Ember.getOwner(this).lookup(`adapter:${singularize(type)}`);\n    if (Adapter && Adapter.pathForType) return Adapter.pathForType(type);\n  },\n  _getPrefix(type) {\n    const Adapter = Ember.getOwner(this).lookup(`adapter:${singularize(type)}`);\n    let prefix;\n    if (Adapter) prefix = Adapter.get(\"prefix\");\n    if (!prefix) prefix = \"\";\n    return prefix;\n  },\n  _factoryFor(type) {\n    let ref;\n    const modelStr = (ref = this.get(\"modelStr\")) ? ref : \"model-sdb\";\n    return Ember.getOwner(this).factoryFor(`${modelStr}:${singularize(type)}`);\n  },\n  _createModel(type, doc) {\n    const modelClass = this._factoryFor(type);\n    if (modelClass) {\n      return modelClass.create({\n        doc,\n        _type: pluralize(type),\n        _store: this,\n      });\n    }\n    throw new Error(`Cannot find model for ${type}`);\n  },\n  _resolveModel(type, doc) {\n    const cache = this._cacheFor(pluralize(type));\n    const id = Ember.get(doc, \"id\") || Ember.get(doc, \"_id\");\n    const model = cache.findBy(\"id\", id);\n    if (model !== undefined) {\n      return Promise.resolve(model);\n    }\n    const store = this;\n    return store.subscribe(doc).then(function (doc) {\n      return store._createModel(type, doc);\n    });\n  },\n  _resolveModels(type, docs) {\n    // type = pluralize(type)\n    const store = this;\n    const cache = this._cacheFor(pluralize(type));\n    const models = [];\n    const promises = [];\n    for (let i = 0; i < docs.length; i++) {\n      const doc = docs[i];\n      const model = cache.findBy(\"id\", doc.id);\n      if (model) {\n        models.push(model);\n      } else {\n        promises.push(this._resolveModel(type, doc));\n      }\n    }\n    return new Promise(function (resolve, reject) {\n      if (!Ember.isEmpty(promises)) {\n        Promise.all(promises)\n          .then(function (resolvedModels) {\n            cache.addObjects(resolvedModels);\n            resolve(models.concat(resolvedModels));\n          })\n          .catch(function (err) {\n            reject(err);\n          });\n      } else {\n        resolve(models);\n      }\n    });\n    // return Promise.all(cache);\n  },\n  /* returns Promise for when sharedb doc is ready */\n  whenReady(doc) {\n    if (doc.state === \"ready\") {\n      return Promise.resolve(doc);\n    }\n    return new Promise(function (resolve, reject) {\n      doc.on(\"load\", function () {\n        Ember.run(null, resolve, doc);\n      });\n    });\n  },\n  unloadRecord(doc, cb) {\n    const cache = this.cache[doc.get(\"_type\")];\n    doc.get(\"doc\").destroy(() => {\n      cache.removeObject(doc);\n      doc.destroy();\n      if (typeof cb === \"function\") return cb();\n    });\n    return this;\n  },\n  unload(type, doc) {\n    type = pluralize(type);\n    const cache = this._cacheFor(type);\n    try {\n      doc.get(\"doc\").destroy(() => {\n        cache.removeObject(doc);\n        doc.destroy();\n      });\n    } catch (e) {}\n    doc.destroy();\n    cache.removeObject(doc);\n  },\n  unloadAll(type) {\n    return new Promise((resolve, reject) => {\n      const cache = this.cache[pluralize(type)] || [];\n      const promises = cache.map((doc) => {\n        return new Promise((resolve) => {\n          doc.get(\"doc\").destroy(() => {\n            doc.destroy();\n            resolve();\n          });\n        });\n      });\n      return Promise.all(promises)\n        .then(() => {\n          cache.removeObjects(cache);\n          resolve();\n        })\n        .catch(reject);\n    });\n  },\n  peekAll(type) {\n    type = pluralize(type);\n    return this._cacheFor(type);\n  },\n  /* returns Promise for when sharedb doc is subscribed */\n  subscribe(doc) {\n    if (doc.subscribed) {\n      return Promise.resolve(doc);\n    }\n    return new Promise(function (resolve, reject) {\n      doc.subscribe(function (err) {\n        if (err === undefined) {\n          Ember.run(null, resolve, doc);\n        } else {\n          Ember.run(null, reject, err);\n        }\n      });\n    });\n  },\n  /* returns Promise for when sharedb json0 type doc is created */\n  create(doc, data) {\n    return new Promise(function (resolve, reject) {\n      doc.create(data, \"json0\", function (err) {\n        if (err === undefined) {\n          Ember.run(null, resolve, doc);\n        } else {\n          Ember.run(null, reject, err);\n        }\n      });\n    });\n  },\n});\n","function guid() {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0;\n    const v = c === \"x\" ? r : (r & 3) | 8;\n    return v.toString(16);\n  });\n}\n\n/*\n * Software License Agreement (BSD License)\n *\n * Copyright (c) 2009-2011, Kevin Decker kpdecker@gmail.com\n *\n * Text diff implementation.\n *\n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n *\n * JsDiff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n * All rights reserved.\n */\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) };\n}\nconst fbDiff = function (ignoreWhitespace) {\n  this.ignoreWhitespace = ignoreWhitespace;\n};\nfbDiff.prototype = {\n  diff(oldString, newString) {\n    // Handle the identity case (this is due to unrolling editLength == 0\n    if (newString === oldString) {\n      return [{ value: newString }];\n    }\n    if (!newString) {\n      return [{ value: oldString, removed: true }];\n    }\n    if (!oldString) {\n      return [{ value: newString, added: true }];\n    }\n\n    newString = this.tokenize(newString);\n    oldString = this.tokenize(oldString);\n\n    const newLen = newString.length;\n    const oldLen = oldString.length;\n    const maxEditLength = newLen + oldLen;\n    const bestPath = [{ newPos: -1, components: [] }];\n\n    // Seed editLength = 0\n    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      return bestPath[0].components;\n    }\n\n    for (let editLength = 1; editLength <= maxEditLength; editLength++) {\n      for (\n        let diagonalPath = -1 * editLength;\n        diagonalPath <= editLength;\n        diagonalPath += 2\n      ) {\n        var basePath;\n        const addPath = bestPath[diagonalPath - 1];\n        const removePath = bestPath[diagonalPath + 1];\n        oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        const canAdd = addPath && addPath.newPos + 1 < newLen;\n        const canRemove = removePath && oldPos >= 0 && oldPos < oldLen;\n        if (!canAdd && !canRemove) {\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n          basePath = clonePath(removePath);\n          this.pushComponent(\n            basePath.components,\n            oldString[oldPos],\n            undefined,\n            true\n          );\n        } else {\n          basePath = clonePath(addPath);\n          basePath.newPos++;\n          this.pushComponent(\n            basePath.components,\n            newString[basePath.newPos],\n            true,\n            undefined\n          );\n        }\n\n        oldPos = this.extractCommon(\n          basePath,\n          newString,\n          oldString,\n          diagonalPath\n        );\n\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return basePath.components;\n        }\n        bestPath[diagonalPath] = basePath;\n      }\n    }\n  },\n\n  pushComponent(components, value, added, removed) {\n    const last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        value: this.join(last.value, value),\n        added,\n        removed,\n      };\n    } else {\n      components.push({ value, added, removed });\n    }\n  },\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    const newLen = newString.length;\n    const oldLen = oldString.length;\n    let { newPos } = basePath;\n    let oldPos = newPos - diagonalPath;\n    while (\n      newPos + 1 < newLen &&\n      oldPos + 1 < oldLen &&\n      this.equals(newString[newPos + 1], oldString[oldPos + 1])\n    ) {\n      newPos++;\n      oldPos++;\n\n      this.pushComponent(\n        basePath.components,\n        newString[newPos],\n        undefined,\n        undefined\n      );\n    }\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n\n  equals(left, right) {\n    const reWhitespace = /\\S/;\n    if (\n      this.ignoreWhitespace &&\n      !reWhitespace.test(left) &&\n      !reWhitespace.test(right)\n    ) {\n      return true;\n    }\n    return left === right;\n  },\n  join(left, right) {\n    return left + right;\n  },\n  tokenize(value) {\n    return value;\n  },\n};\n// copied from https://github.com/Dignifiedquire/share-primus/blob/master/lib/client/share-primus.js\nfunction patchShare() {\n  // Map Primus ready states to ShareJS ready states.\n  const STATES = {};\n  STATES[window.Primus.CLOSED] = \"disconnected\";\n  STATES[window.Primus.OPENING] = \"connecting\";\n  STATES[window.Primus.OPEN] = \"connected\";\n\n  // Override Connection's bindToSocket method with an implementation\n  // that understands Primus Stream.\n  window.sharedb.Connection.prototype.bindToSocket = function (stream) {\n    const connection = this;\n    this.state =\n      stream.readyState === 0 || stream.readyState === 1\n        ? \"connecting\"\n        : \"disconnected\";\n\n    setState(Primus.OPENING);\n    setState(stream.readyState);\n    this.canSend = this.state === \"connected\"; // Primus can't send in connecting state.\n\n    // Tiny facade so Connection can still send() messages.\n    this.socket = {\n      send(msg) {\n        stream.write(msg);\n      },\n    };\n\n    stream.on(\"data\", function (msg) {\n      if (msg.a) {\n        try {\n          connection.handleMessage(msg);\n        } catch (e) {\n          connection.emit(\"error\", e);\n          throw e;\n        }\n      }\n    });\n\n    stream.on(\"readyStateChange\", function () {\n      // console.log(stream.readyState);\n      setState(stream.readyState);\n    });\n\n    stream.on(\"reconnecting\", function () {\n      if (connection.state === \"disconnected\") {\n        setState(Primus.OPENING);\n        connection.canSend = false;\n      }\n    });\n\n    function setState(readyState) {\n      const shareState = STATES[readyState];\n      connection._setState(shareState);\n    }\n  };\n}\nconst isArray =\n  Array.isArray ||\n  function (obj) {\n    return obj instanceof Array;\n  };\nconst diff = new fbDiff(false);\nexport { guid, diff, isArray, patchShare };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(\"./lib/ember-share.js\");\n"],"sourceRoot":""}